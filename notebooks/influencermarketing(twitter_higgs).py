# -*- coding: utf-8 -*-
"""InfluencerMarketing(Twitter-higgs).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iLDfGceu0pQLZy_FztwEI7hKoS010YrW
"""

# from google.colab import drive
# drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install mesa

class Utils:

    @staticmethod
    def id_degree_file_genrator(filepath,new_filepath):
        id_degree_mp = {}
        with open(filepath) as file:
            for line in file:
                x, y = [int(node_id) for node_id in line.split(' ')]
                if(y in id_degree_mp.keys()):
                    id_degree_mp[y]+=1
                else:
                    id_degree_mp[y]=1
        id_degree_mp = {k: v for k, v in sorted(id_degree_mp.items(), key=lambda item: item[1])}

        with open('{}'.format(new_filepath),"w") as file:
            for node_id in id_degree_mp.keys():
                file.write('{},{}\n'.format(node_id,id_degree_mp[node_id]))

    @staticmethod
    def clean_dataset(filepath,new_filepath):
        a = set()
        with open(filepath) as f:
            for l in f:
                # print(l)
                x, y = [int(node_id) for node_id in l.split(' ')]
                a.add((x,y))

        with open("{}".format(new_filepath),"w") as f:
            for i, val in enumerate(a):
                val = list(val)
                f.write(str(val[0]) + " " + str(val[1]) + "\n")


import numpy as np

def RandomGenerator(x, y):
    return random.uniform(x, y)

def gaussianRandomgenerator(x, y, mu, sigma):
    sample = np.random.normal(mu, sigma, None)
    if sample > y:
        sample = y
    elif sample < x:
        sample = x
    else:
        pass
    return sample


def randomTrueFalse(p):
    '''return true with given probability p'''
    return random.uniform(0, 1) <= p




import random
import networkx as nx

class Graph():

    def __init__(self):
        self.graph = {}

    def assign_edge_weights(self):
        for from_node,to_node in self.edges:
            edge_weight = self.get_random_edge_weight('random')
            edge = Edge(to_node,edge_weight)
            if(from_node in self.graph.keys()):
                self.graph[from_node].append(edge)
            else:
                self.graph[from_node] = [edge]

    def get_random_edge_weight(self,rand_type):
        if(rand_type == 'random'):
            return random.random()
        if(rand_type == 'gauss'):
            return gaussianRandomgenerator(0,1,0.7,0.1)

    def create_networkx_graph(self,n,k,p=0.5):
        G = nx.watts_strogatz_graph(n=n, k=k, p=p)
        self.edges = list(G.edges())
        self.nodes = list(G.nodes())

        self.assign_edge_weights()

    def create_twitter_graph(self,filepath):
        self.edges = []
        self.nodes = set()
        with open(filepath) as file:
            for line in file:
                x, y = [int(node_id) for node_id in line.split(' ')]
                self.edges.append((y, x))
                self.nodes.add(x)
                self.nodes.add(y)
        self.nodes = list(self.nodes)

        self.assign_edge_weights()

    def get_nodes(self):
        return self.nodes

class Edge():

    def __init__(self,node_id,weight):
        self.node_id = node_id
        self.weight = weight

    def set_weight(self,weight):
        if(weight>1):
            weight = 1
        if(weight<0):
            weight = 0
        self.weight = weight

from mesa import Agent
import random
class InfluencerAgent(Agent):

    def __init__(self, unique_id, model):
        super().__init__(unique_id, model)
        self.hired = False
        self.hiring_cost = 0
        self.out_degree = 0
        self.decision = False
        self.interest = gaussianRandomgenerator(0, 1, 0.5, 0.2)
        # self.interest = RandomGenerator(0,1)
        self.budget = RandomGenerator(0, 100)
        self.active = True
        self.sig_strength = 0
        self.influenced_by_node_id = -1
        self.engagement_rate = 0

    def get_outDegree(self):
        return self.out_degree

    def set_outDegree(self, out_degree):
        self.out_degree = out_degree

    def set_sigStrength(self, sig_strength):
        self.sig_strength = sig_strength

    def get_interest(self):
        return self.interest

    def get_decision(self):
        return self.decision

    def set_engagement_rate(self):
        mapping = {
            (0,2500): 30,
            (2501,5000): 25,
            (5001,10000): 18,
            (10001,22000): 12,
            (22001,45000): 5,
            (45001,None): 1
        }

        for interval,rate in mapping.items():
            lower, upper = interval
            if(self.out_degree>=lower):
                if(upper == None):
                    self.engagement_rate = rate
                elif(self.out_degree<=upper):
                    self.engagement_rate = rate
                    break

    def set_hiring_cost(self):
        # mapping = {
        #     (0, 50): 5,
        #     (51,200): 10,
        #     (201,400): 40,
        #     (401,1000): 45,  #0.1, 0.05, 0.1, 0.045, 0.02, 0.02
        #     (1001,1500): 30,
        #     (1501,3000): 60,
        #     (3001,None): 200
        # }
        # for interval,rate in mapping.items():
        #     lower, upper = interval
        #     if(self.out_degree>=lower):
        #         if(upper == None):
        #             self.hiring_cost = rate
        #         elif(self.out_degree<=upper):
        #             self.hiring_cost = rate
        #             break
        cost_per_post_per_follower = 0.01
        self.hiring_cost = cost_per_post_per_follower*self.out_degree

    def update_interest(self, influence, decision):
        self.interest_update_function(influence, decision)

    def make_decision(self, influence, signal_strength, product_cost):
        self.decision = self.decision_function(influence, signal_strength, product_cost)
        return self.decision

    def interest_update_function(self, influence, decision):
        gamma = 0.001
        if decision:
            self.interest = self.interest + (self.interest*influence)
        else:
            if randomTrueFalse(gamma):
                self.interest = self.interest - (self.interest*influence)

        if(self.interest<0): self.interest = 0
        if(self.interest>1): self.interest = 1

    def decision_function(self, influence, signal_strength, product_cost):
        self.active = randomTrueFalse(0.95)
        if self.budget >= product_cost and self.active:
            decision = RandomGenerator(0, 1) < (self.interest * influence * signal_strength)
        else:
            decision = False
        return decision

import random
import numpy as np
from queue import Queue
#import matplotlib.pyplot as plt

from mesa import Model
from mesa.space import MultiGrid
from mesa.datacollection import DataCollector

class InfluencerAdvertisingModel(Model):

    def __init__(self, width, height, Graph, node_ids, product_cost, hiring_budget, grid=1):
        '''
        Graph = {
            <node id> : [ <Edge Object> ]
        }
        '''
        self.num_agents = len((Graph.get_nodes()))
        self.graph = Graph
        self.bfs_queue = Queue()
        self.running = True
        self.product_cost = product_cost
        self.current_step = 1
        self.visited_nodes = set()
        self.engage_count = 0
        self.total_hiring_cost = 0
        self.hiring_budget = hiring_budget
        self.setup_datacollector()
        self.generate_agents()
        self.assign_attributes()

        if(grid==1):
            self.grid = MultiGrid(width, height, True)
            self.setup_grid()

        # self.initialize_campaign_marketers(node_ids)
        self.campaign_marketers = node_ids

    def number_bought(self,model):
        count=0
        for _, agent in model.id_agent_mp.items():
            if(agent.decision == True): count+=1
        return count

    def no_bought_every_timestep(self,model):
        return model.bfs_queue.qsize()

    def setup_datacollector(self):
        self.datacollector = DataCollector(
            model_reporters={
                "No bought at every timestep": self.no_bought_every_timestep,
                "No who bought": self.number_bought
            }
            # agent_reporters={"Wealth": "wealth"}
        )

    def generate_agents(self):
        '''
        Creates mapping with keys as the node id, and value as agent class
        '''
        self.id_agent_mp = {}
        for node_id in self.graph.get_nodes():
            agent = InfluencerAgent(node_id,self)
            self.id_agent_mp[node_id] = agent

    def assign_attributes(self):
        for node_id, agent in self.id_agent_mp.items():
            if(node_id in self.graph.graph.keys()):
                degree = len(self.graph.graph[node_id])
                agent.set_outDegree(degree)
                agent.set_engagement_rate()
                agent.set_hiring_cost()
                # agent.set_sigStrength(agent.out_degree / 3383)
                agent.set_sigStrength(1)
            else:
                agent.set_outDegree(0)

    def update_influence_wrt_engagement(self):
        gamma = 0.7
        for agent_id, edges in self.graph.graph.items():
            engagement_rate = self.id_agent_mp[agent_id].engagement_rate
            for edge in edges:
                if(randomTrueFalse(engagement_rate/100)):
                    edge.set_weight(edge.weight + gamma)


    def setup_grid(self,random_position=1):
        '''
        Places agents on the grid
        '''
        if(random_position==1):
            for node_id in self.graph.get_nodes():
                x, y = random.choice(list(self.grid.empties))
                self.grid.place_agent(self.id_agent_mp[node_id], (x, y))
        else:
            node_id = 0
            for row in range(self.grid.width):
                for col in range(self.grid.height):
                    if(node_id == self.num_agents):
                        return
                    self.grid.place_agent(self.id_agent_mp[node_id], (col, row))
                    node_id+=1

    def initialize_campaign_marketers_at_step(self):
        '''
        All the node ids who start the campaign propagation
        '''
        for node_id in self.campaign_marketers.get(self.current_step,[]):
            # print("="*80,self.id_agent_mp[node_id].get_outDegree(),sep='\n')
            self.id_agent_mp[node_id].hired = True
            self.total_hiring_cost += self.id_agent_mp[node_id].hiring_cost
            self.bfs_queue.put(node_id)

    def sig_decay(self, sig_strength, bfs_level):
        return sig_strength * (bfs_level**-(2))

    def propagate_from_node(self,node_id):
        '''
        Given a node, propagates the campaign
        Makes the decision for all the neighours of the given node
        '''
        if(node_id in self.campaign_marketers.get(self.current_step,[])):
            influenced_by = node_id
        else:
            influenced_by = self.id_agent_mp[node_id].influenced_by_node_id

        signal_strength = self.id_agent_mp[influenced_by].sig_strength
        engagement_rate = self.id_agent_mp[node_id].engagement_rate
        hired = self.id_agent_mp[node_id].hired

        gamma = 0.7

        if(node_id in self.graph.graph.keys()):
            for _, ngb_edge in enumerate(self.graph.graph[node_id]):

                ngb_id = ngb_edge.node_id
                weight = ngb_edge.weight
                ngb_agent = self.id_agent_mp[ngb_id]
                if(hired and randomTrueFalse(engagement_rate/100)):

                    weight += gamma
                    self.engage_count += 1

                if(ngb_agent.decision == False and ngb_agent.hired == False):
                    self.visited_nodes.add(ngb_agent)
                    decay_factor = self.sig_decay(signal_strength, self.current_step)
                    decision = ngb_agent.make_decision(weight, decay_factor, self.product_cost)
                    self.update_ngb_nodes_interest(node_id, decision)
                    if(decision == True):
                        ngb_agent.influenced_by_node_id = influenced_by
                        self.bfs_queue.put(ngb_id)

    def update_ngb_nodes_interest(self,node_id, decision):
        '''
        Given the node (who acknowledge the campaign), update interest of it's neighbours
        '''
        if(node_id in self.graph.graph.keys()):
            for _, ngb_edge in enumerate(self.graph.graph[node_id]):

                ngb_id = ngb_edge.node_id
                weight = ngb_edge.weight
                ngb_agent = self.id_agent_mp[ngb_id]

                if(ngb_agent.decision == False):
                    ngb_agent.update_interest(weight, decision)

    def interest_count(self):
        count = [0,0,0,0,0,0,0,0,0,0]
        for _, agent in self.id_agent_mp.items():
            if(agent.interest<=0.1 and agent.interest>=0): count[0] += 1
            if(agent.interest<=0.2 and agent.interest>0.1): count[1] += 1
            if(agent.interest<=0.3 and agent.interest>0.2): count[2] += 1
            if(agent.interest<=0.4 and agent.interest>0.3): count[3] += 1
            if(agent.interest<=0.5 and agent.interest>0.4): count[4] += 1
            if(agent.interest<=0.6 and agent.interest>0.5): count[5] += 1
            if(agent.interest<=0.7 and agent.interest>0.6): count[6] += 1
            if(agent.interest<=0.8 and agent.interest>0.7): count[7] += 1
            if(agent.interest<=0.9 and agent.interest>0.8): count[8] += 1
            if(agent.interest<=1 and agent.interest>0.9): count[9] += 1

        return count

    def interest_histogram(self, interest_data):
        bin_edges = np.arange(0.1, 1.1, 0.1)
        plt.figure(self.current_step)
        plt.bar(bin_edges, interest_data, width = 0.05, alpha = 0.9)
        plt.grid(axis = 'y')
        plt.xticks(bin_edges)
        plt.xlabel('Interval (upperlimit)', horizontalalignment='center')
        plt.ylabel('Number of Agents')
        plt.title('Distribution of Interest in the Agent Population')
        plt.savefig('../experimental_results/interest_distribution/gamma=0.01/step{}.png'.format(self.current_step))

    def print_data(self):
        print('='*30,' ',self.current_step,' ','='*30)
        print('Total agents bought: ',self.number_bought(self))
        print('Total agents bought at current step: ',self.no_bought_every_timestep(self))
        print('Total Hiring Cost: ', self.total_hiring_cost, 'Hiring Budget: ', self.hiring_budget)
        print('Total people reached: ', len(self.visited_nodes))
        print('Interest Distribution: ', self.interest_count())

    def step(self):
        if(self.current_step == 1):
            print('interest Distribution: ', self.interest_count())
        self.initialize_campaign_marketers_at_step()
        n = self.bfs_queue.qsize()
        self.datacollector.collect(self)
        for _ in range(n):
            node_id = self.bfs_queue.get()
            self.propagate_from_node(node_id)
        self.print_data()
        self.current_step += 1

def get_node_ids_inRange(filepath, x, y):
    node_ids = []
    outdegrees = []
    with open(filepath) as f:
        lines = f.readlines()
        for line in lines:
            line = line.strip().split(',')
            id = int(line[0])
            outDegree = int(line[1])

            if outDegree >= x and outDegree <=y:
                node_ids.append(id)
                outdegrees.append(outDegree)
    return node_ids, outdegrees

def choose_random_advertisers(node_ids, outdegrees, n, sort=0):
    advertiser_list = []
    advertiser_outdegrees = []
    idx = random.sample(range(0, len(node_ids)), n)

    if(sort==1):
        sorted_ids_wrt_outdegree = [x for _,x in sorted(zip(outdegrees,node_ids))]
        sorted_outdegree = [y for y,_ in sorted(zip(outdegrees,node_ids))]
        return sorted_ids_wrt_outdegree[-n:], sorted_outdegree[-n:]

    for i in idx:
        advertiser_list.append(node_ids[i])
        advertiser_outdegrees.append(outdegrees[i])
    return advertiser_list, advertiser_outdegrees

def choose_advertisers_with_HiringConstraint(node_ids, outdegrees, total_hiring_cost):
    cost_per_post_per_follower = 0.01
    hiring_cost = 0
    advertiser_list = []
    advertiser_outdegrees = []

    sorted_ids_wrt_outdegree = [x for _,x in sorted(zip(outdegrees,node_ids))]
    sorted_outdegree = [y for y,_ in sorted(zip(outdegrees,node_ids))]
    idx = random.sample(range(0, len(node_ids)), len(node_ids))

    i=0;
    while(i<len(idx)):
        hiring_cost += sorted_outdegree[idx[i]]*cost_per_post_per_follower
        if hiring_cost > total_hiring_cost:
            if i == len(idx) - 1:
#                 print(i,len(idx)-1)
                break
            else:
                i += 1
                continue

        advertiser_list.append(sorted_ids_wrt_outdegree[idx[i]])
        advertiser_outdegrees.append(sorted_outdegree[idx[i]])
        i += 1
    return advertiser_list, advertiser_outdegrees

def choose_best_advertisers_with_HiringConstraint(node_ids, outdegrees, total_hiring_cost):
    cost_per_post_per_follower = 0.01
    hiring_cost = 0
    advertiser_list = []
    advertiser_outdegrees = []

    sorted_ids_wrt_outdegree = [x for _,x in sorted(zip(outdegrees,node_ids))]
    sorted_outdegree = [y for y,_ in sorted(zip(outdegrees,node_ids))]
    i=1;
    while (hiring_cost < total_hiring_cost):
        hiring_cost += sorted_outdegree[-i]*cost_per_post_per_follower
        if hiring_cost > total_hiring_cost:
            break
        advertiser_list.append(sorted_ids_wrt_outdegree[-i])
        advertiser_outdegrees.append(sorted_outdegree[-i])
        i += 1
    return advertiser_list, advertiser_outdegrees

width = height = 50
grid=0
graph = Graph()
graph.create_twitter_graph(filepath='../data/soc-twitter-higgs.txt')
print('Loaded the graph')
f = open('twitter-higgs_experiment_p10_data.csv','a')
f.write('Influencer Level,N,Hiring Cost,Buyers,Outreach\n')
f.close()
for _ in range(5):
  for i in range(1,7):
      print("-"*80)
      mapping = {
            6:(2,2500),
            5:(2501,5000),
            4:(5001,10000),
            3:(10001,22000),
            2:(22001,45000),
            1:(45001,55000)
        }
      node_ids_inRange, outdegrees = get_node_ids_inRange("../data/soc-twitter-higgs_id_degree.txt", mapping[i][0], mapping[i][1])
      max_advertiser_list = []
      max_hiring_cost = 0

      for _ in range(100):
          advertiser_list, advertiser_outdegrees = choose_advertisers_with_HiringConstraint(node_ids_inRange, outdegrees, 1000)
          hiring_cost = sum(advertiser_outdegrees)*0.01
          if (hiring_cost > max_hiring_cost):
              max_advertiser_list = advertiser_list
              max_hiring_cost = hiring_cost

      advertiser_list = max_advertiser_list

      print("Advertiser nodes: ", advertiser_list, "Number of advertisers: ", len(advertiser_list), "\nTotal out degree: ")
      node_ids = {
          1: advertiser_list
      }
      params = {
          "width":width,
          "height":height,
          "Graph": graph,
          "node_ids": node_ids,
          "grid": grid,
          "product_cost": 10,
          "hiring_budget": 1000
      }
      model = InfluencerAdvertisingModel(width,height,graph,node_ids,10,1000,grid)


      for _ in range(15):
          model.step()


      f = open('twitter-higgs_experiment_p10_data.csv','a')
      f.write('{},{},{},{},{}\n'.format(
              i,
              len(model.campaign_marketers[1]),
              model.total_hiring_cost,
              model.number_bought(model),
              len(model.visited_nodes),
          )
      )
      f.close()

f = open('twitter-higgs_experiment_p90_data.csv','a')
f.write('Influencer Level,N,Hiring Cost,Buyers,Outreach\n')
f.close()
for _ in range(5):
  for i in range(1,7):
      print("-"*80)
      mapping = {
            6:(2,2500),
            5:(2501,5000),
            4:(5001,10000),
            3:(10001,22000),
            2:(22001,45000),
            1:(45001,55000)
        }
      node_ids_inRange, outdegrees = get_node_ids_inRange("../data/soc-twitter-higgs_id_degree.txt", mapping[i][0], mapping[i][1])
      max_advertiser_list = []
      max_hiring_cost = 0

      for _ in range(100):
          advertiser_list, advertiser_outdegrees = choose_advertisers_with_HiringConstraint(node_ids_inRange, outdegrees, 1000)
          hiring_cost = sum(advertiser_outdegrees)*0.01
          if (hiring_cost > max_hiring_cost):
              max_advertiser_list = advertiser_list
              max_hiring_cost = hiring_cost

      advertiser_list = max_advertiser_list

      print("Advertiser nodes: ", advertiser_list, "Number of advertisers: ", len(advertiser_list), "\nTotal out degree: ")
      node_ids = {
          1: advertiser_list
      }
      params = {
          "width":width,
          "height":height,
          "Graph": graph,
          "node_ids": node_ids,
          "grid": grid,
          "product_cost": 90,
          "hiring_budget": 1000
      }
      model = InfluencerAdvertisingModel(width,height,graph,node_ids,90,1000,grid)


      for _ in range(15):
          model.step()


      f = open('twitter-higgs_experiment_p90_data.csv','a')
      f.write('{},{},{},{},{}\n'.format(
              i,
              len(model.campaign_marketers[1]),
              model.total_hiring_cost,
              model.number_bought(model),
              len(model.visited_nodes),
          )
      )
      f.close()
